// Copyright 2022 The Swarm Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pinstore

import (
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"sync"

	storage "github.com/ethersphere/bee/pkg/storagev2"
	"github.com/ethersphere/bee/pkg/swarm"
	"github.com/google/uuid"
)

const (
	// size of the UUID generated by the pinstore
	uuidSize = 16
)

var (
	// errInvalidPinCollectionAddr is returned when trying to marshal a pinCollectionItem
	// with a zero address
	errInvalidPinCollectionAddr = errors.New("marshal pinCollectionItem: address is zero")
	// errInvalidPinCollectionUUID is returned when trying to marshal a pinCollectionItem
	// with an empty UUID
	errInvalidPinCollectionUUID = errors.New("marshal pinCollectionItem: UUID is zero")
	// errInvalidPinCollectionSize is returned when trying to unmarshal a buffer of
	// incorrect size
	errInvalidPinCollectionSize = errors.New("unmarshal pinCollectionItem: invalid size")
)

// batchSize used for deletion
var batchSize = 100

// CollectionStat is used to store some basic stats about the pinning collection
type CollectionStat struct {
	Total           uint64
	DupInCollection uint64
}

// pinCollectionSize represents the size of the pinCollectionItem
const pinCollectionItemSize = swarm.HashSize + uuidSize + 8 + 8

// pinCollectionItem is the index used to describe a pinning collection. The Addr
// is the root reference of the collection and UUID is a unique UUID for this collection.
type pinCollectionItem struct {
	Addr swarm.Address
	UUID []byte
	Stat CollectionStat
}

// common prefix for all pinCollectionItem entries
func (pinCollectionItem) Namespace() string { return "pinCollectionItem" }

func (p *pinCollectionItem) ID() string { return p.Addr.ByteString() }

func (p *pinCollectionItem) Marshal() ([]byte, error) {
	if p.Addr.IsZero() {
		return nil, errInvalidPinCollectionAddr
	}
	if len(p.UUID) == 0 {
		return nil, errInvalidPinCollectionUUID
	}
	buf := make([]byte, pinCollectionItemSize)
	copy(buf[:swarm.HashSize], p.Addr.Bytes())
	copy(buf[swarm.HashSize:swarm.HashSize+uuidSize], p.UUID)
	statBufOff := swarm.HashSize + uuidSize
	binary.LittleEndian.PutUint64(buf[statBufOff:], p.Stat.Total)
	binary.LittleEndian.PutUint64(buf[statBufOff+8:], p.Stat.DupInCollection)
	return buf, nil
}

func (p *pinCollectionItem) Unmarshal(buf []byte) error {
	if len(buf) != pinCollectionItemSize {
		return errInvalidPinCollectionSize
	}
	ni := new(pinCollectionItem)
	ni.Addr = swarm.NewAddress(buf[:swarm.HashSize])
	ni.UUID = buf[swarm.HashSize : swarm.HashSize+uuidSize]
	statBuf := buf[swarm.HashSize+uuidSize:]
	ni.Stat.Total = binary.LittleEndian.Uint64(statBuf[:8])
	ni.Stat.DupInCollection = binary.LittleEndian.Uint64(statBuf[8:16])
	*p = *ni
	return nil
}

// pinChunkItem is the index used to represent a single chunk in the pinning
// collection. It is prefixed with the UUID of the collection.
type pinChunkItem struct {
	UUID []byte
	Addr swarm.Address
}

func (p *pinChunkItem) Namespace() string { return string(p.UUID) }

func (p *pinChunkItem) ID() string { return p.Addr.ByteString() }

// pinChunkItem is a key-only type index. We don't need to store any value. As such
// the serialization functions would be no-ops. A Get operation on this key is not
// required as the key would constitute the item. Usually these type of indexes are
// useful for key-only iterations.
func (p *pinChunkItem) Marshal() ([]byte, error) {
	return []byte{}, nil
}

func (p *pinChunkItem) Unmarshal(_ []byte) error {
	return nil
}

// PutterCloser implements the storage.Putter as well as an io.Closer. The Putter
// should be closed for a successful operation.
type PutterCloser interface {
	storage.Putter
	io.Closer
}

// Storage interface is the functionality required from the underlying storage to
// achieve the pinstore functionality. This allows us to do stateless operations
// here.
type Storage interface {
	Ctx() context.Context
	Store() storage.Store
	ChunkStore() storage.ChunkStore
}

// NewCollection returns a putter wrapped around the passed storage.
// The putter will add the chunk to Chunk store if it doesnt exists within this collection.
// It will create a new UUID for the collection which can be used to iterate on all the chunks
// that are part of this collection. The root pin is only updated on successful close of this
// Putter.
func NewCollection(st Storage, root swarm.Address) (PutterCloser, error) {

	id := uuid.New()
	collection := &pinCollectionItem{Addr: root, UUID: id[:]}
	found, err := st.Store().Has(collection)
	if err != nil {
		return nil, fmt.Errorf("pin store: failed checking collection: %w", err)
	}
	if found {
		return nil, fmt.Errorf("pin store: root %s already exists", root)
	}

	return &collectionPutter{collection: collection, st: st}, nil
}

type collectionPutter struct {
	mtx        sync.Mutex
	collection *pinCollectionItem
	st         Storage
}

func (c *collectionPutter) Put(ctx context.Context, ch swarm.Chunk) (bool, error) {
	c.mtx.Lock()
	defer c.mtx.Unlock()

	c.collection.Stat.Total++

	// We will only care about duplicates within this collection. In order to
	// guarantee that we dont accidentally delete common chunks across collections,
	// a separate pinCollectionItem entry will be present for each duplicate chunk.
	collectionChunk := &pinChunkItem{UUID: c.collection.UUID, Addr: ch.Address()}
	found, err := c.st.Store().Has(collectionChunk)
	if err != nil {
		return false, fmt.Errorf("pin store: failed to check chunk: %w", err)
	}
	if found {
		// If we already have this chunk in the current collection, don't add it
		// again.
		c.collection.Stat.DupInCollection++
		return true, nil
	}

	err = c.st.Store().Put(collectionChunk)
	if err != nil {
		return false, fmt.Errorf("pin store: failed putting collection chunk: %w", err)
	}

	_, err = c.st.ChunkStore().Put(ctx, ch)
	if err != nil {
		return false, fmt.Errorf("pin store: failled putting chunk: %w", err)
	}

	return false, nil
}

func (c *collectionPutter) Close() error {
	c.mtx.Lock()
	defer c.mtx.Unlock()

	// Save the root pin reference.
	err := c.st.Store().Put(c.collection)
	if err != nil {
		return fmt.Errorf("pin store: failed updating collection: %w", err)
	}
	return nil
}

// HasPin function will check if the address represents a valid pin collection.
func HasPin(st storage.Store, root swarm.Address) (bool, error) {
	collection := &pinCollectionItem{Addr: root}
	has, err := st.Has(collection)
	if err != nil {
		return false, fmt.Errorf("pin store: failed checking collection: %w", err)
	}
	return has, nil
}

// Pins lists all the added pinning collections.
func Pins(st storage.Store) ([]swarm.Address, error) {
	var pins []swarm.Address
	err := st.Iterate(storage.Query{
		Factory:       func() storage.Item { return new(pinCollectionItem) },
		ItemAttribute: storage.QueryItemID,
	}, func(r storage.Result) (bool, error) {
		addr := swarm.NewAddress([]byte(r.ID))
		pins = append(pins, addr)
		return false, nil
	})
	if err != nil {
		return nil, fmt.Errorf("pin store: failed iterating root refs: %w", err)
	}

	return pins, nil
}

// DeletePin will delete the root pin and all the chunks that are part of this
// collection.
func DeletePin(st Storage, root swarm.Address) error {
	collection := &pinCollectionItem{Addr: root}
	err := st.Store().Get(collection)
	if err != nil {
		return fmt.Errorf("pin store: failed getting collection: %w", err)
	}

	var offset uint64
	total := collection.Stat.Total - collection.Stat.DupInCollection
	for ; offset < total; offset += uint64(batchSize) {
		addrsToDelete := make([]swarm.Address, 0, batchSize)
		countInBatch := 0

		err = st.Store().Iterate(storage.Query{
			Factory:       func() storage.Item { return &pinChunkItem{UUID: collection.UUID} },
			ItemAttribute: storage.QueryItemID,
		}, func(r storage.Result) (bool, error) {
			addr := swarm.NewAddress([]byte(r.ID))
			addrsToDelete = append(addrsToDelete, addr)
			countInBatch++
			if countInBatch == batchSize {
				return true, nil
			}
			return false, nil

		})
		if err != nil {
			return fmt.Errorf("pin store: failed in iteration: %w", err)
		}

		for _, addr := range addrsToDelete {
			chunk := &pinChunkItem{UUID: collection.UUID, Addr: addr}
			err := st.Store().Delete(chunk)
			if err != nil {
				return fmt.Errorf("pin store: failed in batch deletion: %w", err)
			}
			err = st.ChunkStore().Delete(st.Ctx(), chunk.Addr)
			if err != nil {
				return fmt.Errorf("pin store: failed in batch chunk deletion: %w", err)
			}
		}
	}

	err = st.Store().Delete(collection)
	if err != nil {
		return fmt.Errorf("pin store: failed deleting root collection: %w", err)
	}

	return nil
}
